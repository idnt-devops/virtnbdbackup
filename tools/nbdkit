#   nbdkit -f -v python ./nbdkit blockmap=blocks.json disk=vda.copy.data -t 1
import os
import builtins
import nbdkit
import json
import pprint
API_VERSION = 2

map = None
image = None

def config(key, value):
    global map
    global image
    if key == "blockmap":
        map = json.loads(builtins.open(value,'r').read())
        return
    if key == "disk":
        image = value
        return

    raise RuntimeError("unknown parameter: " + key)

def config_complete():
    global image
    global map
    if image is None or map is None:
        raise RuntimeError("file and disk parameter is required")

    pprint.pprint(map)

def thread_model():
    return nbdkit.THREAD_MODEL_PARALLEL

def open(readonly):
    if readonly:
        flags = os.O_RDONLY
    else:
        flags = os.O_RDWR
    fd = os.open(image, flags)
    return {'fd': fd}

def get_size(h):
    global map
    size = 0
    for m in map:
        size+=m['length']
    return size

def pread(h, buf, offset, flags):
    global map
    # TODO
    # direct match in blockmap:
    #
    # get block where offset sort of matches
    #  list(filter(lambda x:x["originalOffset"]<=65536,blocks))[-1]
    #
    # if offset+length < length, read available read data and return,
    # if not position seek next block and read, repeat until all data read,
    # return data:
    #    list(filter(lambda x:x["nextBlockOffset"]==133300734,blocks))
    #
    blockList = list(filter(lambda x:x["originalOffset"]<=offset,map))
    if len(blockList) == 1:
        block = blockList[0]
    else:
        block = blockList[-1]

    nbdkit.debug("%s" % block)

    if block['nextBlockOffset'] is None:
        # TODO
        nbdkit.debug('READ FROM END OF FILE')
    fileOffset = block['offset']-block['originalOffset']+offset

    dataRange  = fileOffset+len(buf)
    blockRange = fileOffset+block['length']:
    isData     = block['data']
    nbdkit.debug('READ AT: %s' % fileOffset)
    nbdkit.debug('READ: %s' % len(buf))

    if dataRange <= blockRange:
        nbdkit.debug('can read everything')
    else:
        # TODO: in case length is requested which requires to
        # use the next block in the blockmap, partial read data
        # from this block and handle
        if isData is True:
            raise RuntimeError('need data from next block')

    if isData is False:
        nbdkit.debug('handle zero')
        buf = '\0'*len(buf)
    else:
        n = os.preadv(h['fd'], [buf], fileOffset)
        nbdkit.debug("readed: %s" % n)
        if n != len(buf):
            raise RuntimeError("unexpected short read from file")
