#   nbdkit -f -v python ./nbdkit blockmap=blocks.json disk=vda.copy.data -t 1
import os
import builtins
import nbdkit
import json
import pprint
API_VERSION = 2

map = None
image = None

def config(key, value):
    global map
    global image
    if key == "blockmap":
        map = json.loads(builtins.open(value,'r').read())
        return
    if key == "disk":
        image = value
        return

    raise RuntimeError("unknown parameter: " + key)

def config_complete():
    global image
    global map
    if image is None or map is None:
        raise RuntimeError("file and disk parameter is required")

    pprint.pprint(map)

def thread_model():
    return nbdkit.THREAD_MODEL_PARALLEL

def open(readonly):
    if readonly:
        flags = os.O_RDONLY
    else:
        flags = os.O_RDWR
    fd = os.open(image, flags)
    return {'fd': fd}

def close(foo):
    return 1

def get_size(h):
    global map
    size = 0
    for m in map:
        size+=m['length']
    nbdkit.debug('SIZE: %s' % size)
    return size

def pread(h, buf, offset, flags):
    global map
    # TODO
    # direct match in blockmap:
    #
    # get block where offset sort of matches
    #  list(filter(lambda x:x["originalOffset"]<=65536,blocks))[-1]
    #
    # if offset+length < length, read available read data and return,
    # if not position seek next block and read, repeat until all data read,
    # return data:
    #    list(filter(lambda x:x["nextBlockOffset"]==133300734,blocks))
    #
    data = bytearray()
    blockList = list(filter(lambda x:x["originalOffset"]<=offset,map))
    if len(blockList) == 1:
        block = blockList[0]
    else:
        block = blockList[-1]

    nbdkit.debug("%s" % block)

    if block['nextBlockOffset'] is None:
        # TODO
        nbdkit.debug('READ FROM END OF FILE')
    fileOffset = block['offset']-block['originalOffset']+offset

    dataRange  = fileOffset+len(buf)
    blockRange = fileOffset+block['length']
    isData     = block['data']
    nbdkit.debug('READ AT: %s' % fileOffset)
    nbdkit.debug('READ: %s' % len(buf))
    nbdkit.debug('DATA-RANGE: %s' % dataRange)
    nbdkit.debug('BLOCK-RANGE: %s' % blockRange)

    if dataRange < blockRange:
        if isData is False:
            nbdkit.debug('handle zero')
            data += b'\0'*len(buf)
        else:
            nbdkit.debug('can read everything')
            data += os.pread(h['fd'], len(buf), fileOffset)
            nbdkit.debug("readed: %s" % len(data))
    else:
        # TODO: in case length is requested which requires to
        # use the next block in the blockmap, partial read data
        # from this block and handle
        #
        #
        canRead = len(buf)-block['length']
        if isData is False and canRead > 0:
            nbdkit.debug('handle zero for first part')
            data += b'\0'*len(canRead)
        else:
            if canRead != 0:
                nbdkit.debug('Can read from this block: %s' % canRead)
                data += os.pread(h['fd'], canRead, fileOffset)

                nbdkit.debug('did read: %s' % len(buf))
                leftOver = len(buf)-len(data)
                nbdkit.debug('still need to read read: %s' % leftOver)
            else:
                leftOver = len(buf)

            nbdkit.debug('Proceed with next block')
            nextBlock = list(filter(lambda x:x["offset"]==block["nextBlockOffset"],map))[0]

            if nextBlock['data'] is False:
                data += b'\0'*leftOver
                nbdkit.debug('next block is zero')
            else:
                nbdkit.debug("%s" % nextBlock)
                nbdkit.debug("read now: %s" % leftOver)
                fileOffset = nextBlock['offset']

                blockRange = fileOffset+nextBlock['length']

                if leftOver > blockRange:
                    raise RuntimeError('unhandled situation')

                nbdkit.debug("read now: %s from offset: %s" % (leftOver, fileOffset))
                data += os.pread(h['fd'], leftOver, fileOffset)
                nbdkit.debug('did read: %s' % len(data))

    if len(data) != len(buf):
        raise RuntimeError("unexpected short read from file")

    buf[:] = data
